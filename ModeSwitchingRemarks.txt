In this branch, we implement option 2 of the the 3 options for mode switching detailed below
=======================================================
3 OPTIONS
- 1. All or nothing look ahead
- --- in this one, activate and deactivate commands are sent in one call. The system checks the readiness of all paradigms involved. If everyone is ready all the commands get executed in order. This way we avoid the complexities and problems associated with partial de/activations. However we rely on the assumption that readiness is not going to change after we take the leap to start carrying out the de/activations.
- 2. one paradigm at a time with conflict checks and waiting .
- --- this one is a bit more complex but it has two advantages.
- --- --- 1. don't need to worry so much about readiness changes because we don't require one uninterupted stream of de/activations. 
- --- --- 2. we allow the user to hold down buttons that are being deactivated and wait for them to release, giving some flexibility.
- 3. one mode at a time, waiting for all paradigms in the mode to be ready. Persisting until readiness is reached and de/activation complete. That last part is important. It prevents a stream of commands from being aborted after the point of no return (after a mode or modes have already been de/activated).
==========================================================
Optin 2 BLUEPRINT

- LP_.keyState
- --- reserve(String button, EventProcessor ep)
- --- --- PARAMS:
- --- --- --- ep: yep
- --- --- --- button:  (may also be a scan code). Should be formatted in accordance with the value returned by LP_.keyState.format(String)
- --- --- INTERFACE: 
- --- --- --- Prior to completing activation, an EventProcessor ep,  should call this to report intent to activate and receive confirmation that no other active EventProcessor is occupying the button, no other EventProcessors started waiting to occupy the button before ep, and the button is not currently down.  If  all those conditions are satisfied, the button becomes occupied by ep and the method returns true.  If the button is not available for immediate occupation, then ep will be added to the waiting list and alerted whenever occupation is acheived. Alert comes as a call to ep.receiveOccupationConfirmation(button)
- --- --- --- definition:  an EventProcessor is said to "explicitly occupy a button", if it is active and its paradigm explicity modifies the button (I.E. declares a hotkey using the button name or using the scancode if the button is a scancode). 
- --- --- --- definition:  an EventProcessor, ep, is said to "implicitly occupy a button" if one of the following is true:
- --- --- --- --- the button is a scancode and ep is active and its paradigm modifies a button that has that scancode
- --- --- --- --- the button is not a scancode and ep is active and its paradigm modifies the scancode of the button.
- --- --- IMPLEMENTATION: 
- --- --- --- there is some complication when it comes to waiting lists and checking due to dependencies
https://docs.google.com/drawings/d/12P7_ZwgnjDVV47tOwK6IlJ3isOzet8g8UaJhBbN13BA/edit
- --- --- --- see section below
- --- relinquish(String button, EventProcessor ep)
====================Waiting Lists=====================
-occupied status is organized like below. SC1 represents a Scancode and button1 and button2 represent button names associated with that scancode
--------------------------
-SC1 
- --- occupiers
- --- --- scancode:
- --- --- button1:
- --- --- button2:  
- --- waiters: array of objects of form: {eventProcessor, button}
------------------------------
- if ep modifies a ScanCode explicitly (rather than specifying a button), then we must check if anyone is currently occupying button1 as well as button 2 as well as the scancode
- if ep  specifies a button then we must check if anyone is currently occupying that button and also check the scancode
- if no one occupies scan code than someone can wait on button 1 while someone else waits on button 2
- I think maybe a tree/list would work well in this circumstance. (inventor's paradox?)
- --- hmmm maybe not. tried to work out example but didnt get very far
- Let's just go with an array of waiters. When reserve is called push {eventProcessor:ep,button:button} into the array. Then if array.count is one we check if array[1].button is occupied and if not we pop it out of waiting, put ep in occupationByScanCode[<SC>].occupiers[button] and call ep.receiveOccupationConfirmation(button) and if button is a scan code we stop processing, otherwise we continue down the array (scancodes implicitly occupy all associated buttons).- See example of what an element of occupationByScanCode might look like below if we did do an array
- --- no that's not cool. even if array count is >1 there are still times when the last pushed can be activated (eg. when proceeded by a scancode or another button with just another button occupying). Most likely at this point no one else in the list can occupy, unless this call to reserve interupted a relinquish call or other call to reserve. But the latter won't happen because we have an activation Q. So what if this call to reserve did indeed interupt a relinquish and the relinquish started going through the occupationByScanCode and checking the waiters? Two threads modifying the same array. Sounds like trouble. I say this array business is a waste of time. We have already asserted that the end coder should ensure that active modes should be deactivated before conflicting modes are activated. Furthermore there should be no conflict within the mode itself. Furthermore de/activations are processed in queue and removal from wait requires no callbacks, i.e. removal of all waits associated with a mode is atomic with respect to any adding of waits from subsequent activations. 

=====================EXAMPLE=============================
Imagine that "button1" and "button2" are actual button names associated with scan code "SC1"
************0*************
neither the scancode nor any buttons associated with the scancode are occupied
-SC1   
- --- occupiers   
- --- --- scancode   
- --- --- button1  
- --- --- button2  
- --- waiters: 
ACTION: LP_.keyState.reserve("SC1",P1)
************1*************
-SC1 
- --- occupiers
- --- --- scancode: P1
- --- --- button1  
- --- --- button2  
- --- waiters: 
ACTION: LP_.keyState.reserve("button1",P2)
************2*************
P2 must wait for P1
--------------------------
-SC1 
- --- occupiers
- --- --- scancode: P1
- --- --- button1  
- --- --- button2  
- --- waiters: {eventProcessor:P2, button:"button1"}
ACTION: LP_.keyState.reserve("button2",P3)
************3*************

--------------------------
-SC1 
- --- occupiers
- --- --- scancode: P1
- --- --- button1  
- --- --- button2  
- --- waiters: {eventProcessor:P2, button:"button1"} {eventProcessor:P3, button:"button2"}
ACTION: LP_.keyState.reserve("SC1",P4)
************4*************

--------------------------
- SC1 
- --- occupiers
- --- --- scancode: P1
- --- --- button1  
- --- --- button2  
- --- waiters: {eventProcessor:P2, button:"button1"} {eventProcessor:P3, button:"button2"} {eventProcessor:P4, button:"SC1"}
ACTION: LP_.keyState.relinquish("SC1",P1)

************5*************

--------------------------
- SC1 
- --- occupiers
- --- --- scancode:
- --- --- button1 : P2
- --- --- button2  : P3
- --- waiters:   {eventProcessor:P4, button:"SC1"}
ACTION: LP_.keyState.relinquish("SC1",P1)